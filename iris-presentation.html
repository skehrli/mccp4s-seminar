<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Iris</title>
<meta name="author" content="Xinglu & Sascha"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/theme/moon.css" id="theme"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Iris</h1><h2 class="author">Xinglu &amp; Sascha</h2>
</section>

<section>
<section id="slide-org1c95717">
<h2 id="org1c95717">What is Iris?</h2>
<div class="outline-text-2" id="text-org1c95717">
</div>
</section>
<section id="slide-orgc8e2470">
<h3 id="orgc8e2470">Disclaimer</h3>
<ul>
<li class="fragment appear">Iris is not a small project</li>
<li class="fragment appear">123 papers and 21 doctoral theses</li>
<li class="fragment appear">Highly influential
<ul>
<li class="fragment appear">2023 Alonzo Church Award for Outstanding Contributions to Logic and Computation</li>
<li class="fragment appear">2025 Most Influential POPL Paper Award
<ul>
<li>awarded for most influential paper of last decade</li>

</ul></li>

</ul></li>

</ul>
</section>
<section id="slide-org46053cc">
<h3 id="org46053cc">Iris in one sentence</h3>
<ul>
<li class="fragment appear">Iris is a <b>generic higher-order concurrent separation logic</b>.</li>

</ul>
</section>
<section id="slide-orgd8ff573">
<h3 id="orgd8ff573">Iris in one (longer) sentence</h3>
<p class="fragment (appear)">
Iris is a framework for
</p>
<ul>
<li class="fragment appear">foundational machine-checked proofs</li>
<li class="fragment appear">of deep correctness properties</li>
<li class="fragment appear">for fine-grained concurrent programs</li>
<li class="fragment appear">in higher-order imperative languages</li>

</ul>
</section>
<section id="slide-orga50704a">
<h3 id="orga50704a">Some Notes</h3>
<ul>
<li class="fragment appear">formalized entirely in Rocq proof assistant</li>
<li class="fragment appear">not tied to particular language semantics</li>
<li class="fragment appear">example: type safety proof of (a realistic subset of) Rust formalized using Iris</li>

</ul>
</section>
</section>
<section>
<section id="slide-orgfbe1c84">
<h2 id="orgfbe1c84">Who is behind Iris?</h2>

<div id="org12663f2" class="figure">
<p><img src="authors.png" alt="authors.png" />
</p>
</div>
</section>
</section>
<section>
<section id="slide-orgc6807a0">
<h2 id="orgc6807a0">A Brief History of Separation logic</h2>
<div class="outline-text-2" id="text-orgc6807a0">
</div>
</section>
<section id="slide-org4d371cf">
<h3 id="org4d371cf">What is Separation Logic?</h3>
<ul>
<li class="fragment appear">extension of Hoare Logic</li>
<li class="fragment appear">allows reasoning about pointer-manipulating programs</li>
<li class="fragment appear">initially introduced by O'Hearn in 2001</li>
<li class="fragment appear">later extended to CSL</li>
<li class="fragment appear">solves two problems - Object Orientation and Concurrency</li>

</ul>
</section>
<section id="slide-org65a65fa">
<h3 id="org65a65fa">Motivation: Why Separation Logic?</h3>
<ul>
<li class="fragment appear"><p>
Consider program:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #005f5f;">void</span> <span style="color: #721045;">f</span><span style="color: #000000;">(</span><span style="color: #005f5f;">int</span>* <span style="color: #005e8b;">x</span>, <span style="color: #005f5f;">int</span>* <span style="color: #005e8b;">y</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
  *x = 1;
  *y = 2;
<span style="color: #000000;">}</span>
</pre>
</div></li>
<li class="fragment appear"><p>
Naive Hoare logic spec:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #000000;">{</span> <span style="color: #0000b0;">true</span> <span style="color: #000000;">}</span> f <span style="color: #000000;">{</span> *x == 1 ^ *y == 2 <span style="color: #000000;">}</span>
</pre>
</div></li>
<li class="fragment appear">What if \(x == y\)? Spec becomes invalid!</li>
<li class="fragment appear"><p>
What we want instead:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #000000;">{</span> <span style="color: #3548cf;">"x and y disjoint"</span> <span style="color: #000000;">}</span> f <span style="color: #000000;">{</span> *x == 1 ^ *y == 2 <span style="color: #000000;">}</span>
</pre>
</div></li>

</ul>
</section>
<section id="slide-org4ec24f1">
<h3 id="org4ec24f1">Separation Logic: Notation</h3>
<ul>
<li class="fragment appear">\(↦\) : points-to assertion (e.g., \(x ↦ 5\))</li>
<li class="fragment appear">\(*\) : separating conjunction (asserts disjointness)</li>
<li class="fragment appear"><p>
Can now formulate this:
</p>
<div>
\begin{aligned}
\{ x ↦ \_ * y ↦ \_ \}\ f\ \{ x ↦ 1 * y ↦ 2 \}
\end{aligned}

</div></li>

</ul>
</section>
<section id="slide-org052b076">
<h3 id="org052b076">Semantics of \(*\)</h3>
<div>
\begin{aligned}
(P * Q)(h) \iff \exists h_1, h_2.~ h = h_1 \uplus h_2 \land P(h_1) \land Q(h_2)
\end{aligned}

</div>
<ul>
<li class="fragment appear">\(P * Q\) holds if:
<ul>
<li>Heap can be split into disjoint parts \(h1,\ h2\)</li>
<li>\(P\) holds on \(h1\), \(Q\) on \(h2\)</li>

</ul></li>

</ul>
</section>
<section id="slide-orgcdb08e0">
<h3 id="orgcdb08e0">Frame Rule</h3>
<div>
\begin{aligned}
\frac{\{P\}~C~\{Q\}}{\{P * R\}~C~\{Q * R\}}
\end{aligned}

</div>

<ul>
<li class="fragment appear">Useful for local reasoning.</li>
<li class="fragment appear">Add unaffected context \(R\) without changing correctness.</li>

</ul>
</section>
<section id="slide-orgf98add1">
<h3 id="orgf98add1">Conclusion thus far</h3>
<ul>
<li class="fragment appear">Convenient reasoning for shared heap where everyone operates on disjoint data</li>
<li class="fragment appear">But at some point, there <b>will</b> be shared data</li>

</ul>
</section>
</section>
<section>
<section id="slide-org284df4e">
<h2 id="org284df4e">CSL: Reasoning about shared data</h2>
<div class="outline-text-2" id="text-org284df4e">
</div>
</section>
<section id="slide-org906ca56">
<h3 id="org906ca56">Separation Logic &rarr; CSL: O'Hearn 2007</h3>
<ul>
<li>O'Hearns CSL = SL + resource invariants</li>
<li>a quick example</li>
<li>ppl liked this, avalanche of subsequent works</li>
<li>problem: every new paper/library had a slightly different way about the shared data reasoning part</li>
<li>everyone came up with their own separation logic with its own primitives and proof rules</li>
<li>positional paper 2010: CSL must be unified, a common framework s.t. ppl can focus on actually verifying things and not respin the metatheory every time</li>

</ul>
</section>
</section>
<section>
<section id="slide-orgfb57313">
<h2 id="orgfb57313">Enter Iris: CSL Unified</h2>
<ul>
<li>Iris is the unifying framework</li>
<li>the premise: Monoids + Invariants is all you need</li>
<li>neither idea is new, but Iris conveys how all of these previous works are some linear combination of Monoids + Invariants</li>

</ul>
</section>
</section>
<section>
<section id="slide-orga14e512">
<h2 id="orga14e512">Wdym Monoids + Invariants??</h2>
<div class="outline-text-2" id="text-orga14e512">
</div>
</section>
<section id="slide-org43b7968">
<h3 id="org43b7968">Where we are so far</h3>
<ul>
<li class="fragment appear">have idea of what CSL is</li>
<li class="fragment appear">know the context and goal of Iris</li>
<li class="fragment appear">BUT
<ul>
<li class="fragment appear">what kinds of proofs do we do in Iris?</li>
<li class="fragment appear">how exactly does the Iris logic look like?</li>

</ul></li>
<li class="fragment appear">let's answer this with an example</li>

</ul>
</section>
<section id="slide-org32b9b34">
<h3 id="org32b9b34">Invariants</h3>
<ul>
<li>Allow us to reason about shared state</li>
<li>Notation: \(\boxed{R}\)</li>
<li>Duplicatable: \(\boxed{R} \vdash \boxed{R} \ast \boxed{R}\)</li>

</ul>
</section>
<section id="slide-org6461b6e">
<h4 id="org6461b6e">Working with Invariants</h4>
<p>
\[
\frac{\left\{ R \ast P \right\} \ e \ \left\{ R \ast Q \right\} \qquad e
\text{ atomic} }{\left\{ \boxed{R} \ast P \right\} \ e \ \left\{ \boxed{R} \ast Q \right\} }
\]
</p>

<ul>
<li>Invariant rule
<ul>
<li class="fragment appear">Open invariant to acquire temporary ownership of shared resource</li>
<li class="fragment appear">Once invariant is reestablished, it can be closed again</li>

</ul></li>

</ul>
</section>
<section id="slide-orgf6290f5">
<h4 id="orgf6290f5">Working with Invariants (cont'd)</h4>
<p>
\[
\frac{\left\{ \boxed{R} \ast P \right\} \ e \ \left\{ Q \right\}
}{\left\{ R \ast P \right\} \ e \ \left\{ Q \right\} }
\]
</p>

<ul>
<li>Allocation rule
<ul>
<li class="fragment appear">Create invariant and give up ownership of \(R\)</li>

</ul></li>

</ul>
</section>
<section id="slide-org9a27291">
<h4 id="org9a27291">Monoids</h4>
<ul>
<li class="fragment appear">Ghost state
<ul>
<li class="fragment appear">Purely logical, separate from the physical state of the program</li>
<li class="fragment appear">Keep track of history of computation</li>

</ul></li>
<li class="fragment appear">Modelled as a <i>partial commutative monoid</i> (PCM)</li>
<li class="fragment appear">Set \(\lvert M \rvert \) with a zero \(\bot\), unit \(\epsilon\),
binary operation \(\cdot \)
<ul>
<li class="fragment appear">\(a \cdot b = b \cdot a\)</li>
<li class="fragment appear">\(\epsilon \cdot a = a \)</li>
<li class="fragment appear">\((a \cdot b) \cdot c = a \cdot (b \cdot c)\)</li>
<li class="fragment appear">\(\bot \cdot a = \bot\)</li>
<li class="fragment appear">\(\bot \neq \epsilon\)</li>

</ul></li>

</ul>
</section>
<section id="slide-org1eb23c4">
<h4 id="org1eb23c4">Example</h4>
<div class="org-src-container">

<pre class="fragment (appear)"><span style="color: #000000;">{</span> l &#8614; n <span style="color: #000000;">}</span>
l &#8592; addOne<span style="color: #000000;">(</span>l<span style="color: #000000;">)</span> &#8214; l &#8592; addOne<span style="color: #000000;">(</span>l<span style="color: #000000;">)</span>
<span style="color: #a60000; font-weight: bold;">!</span>l
<span style="color: #000000;">{</span> v. v &#8805; n + 1 <span style="color: #000000;">}</span>
</pre>
</div>

<ul>
<li>where <code>addOne(l)</code> is an atomic version of <code>!l + 1</code>.</li>

</ul>
</section>
<section id="slide-orgf86fee6">
<h3 id="orgf86fee6">An example program</h3>
<ul>
<li class="fragment appear">Consider instantiation of Iris with a &lambda;-Calculus</li>
<li class="fragment appear"><p>
Consider the following object:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #0000b0;">mk_oneshot</span> := &#955;_.
    let x = ref<span style="color: #000000;">(</span>inl<span style="color: #dd22dd;">(</span>0<span style="color: #dd22dd;">)</span><span style="color: #000000;">)</span> in <span style="color: #000000;">{</span>
      tryset = &#955;n. CAS<span style="color: #dd22dd;">(</span>x, inl<span style="color: #008899;">(</span>0<span style="color: #008899;">)</span>, inr<span style="color: #008899;">(</span>n<span style="color: #008899;">)</span><span style="color: #dd22dd;">)</span>,
      check = &#955;_.
        let y = <span style="color: #a60000; font-weight: bold;">!</span>x in &#955;_.
          match y,<span style="color: #a60000; font-weight: bold;">!</span>x with
            | inl<span style="color: #dd22dd;">(</span>_<span style="color: #dd22dd;">)</span>,_      &#8658; <span style="color: #dd22dd;">()</span>
            | inr<span style="color: #dd22dd;">(</span>n<span style="color: #dd22dd;">)</span>,inl<span style="color: #dd22dd;">(</span>_<span style="color: #dd22dd;">)</span> &#8658; assert<span style="color: #dd22dd;">(</span><span style="color: #0000b0;">false</span><span style="color: #dd22dd;">)</span>
            | inr<span style="color: #dd22dd;">(</span>n<span style="color: #dd22dd;">)</span>,inr<span style="color: #dd22dd;">(</span>m<span style="color: #dd22dd;">)</span> &#8658; assert<span style="color: #dd22dd;">(</span>n = m<span style="color: #dd22dd;">)</span>
          end
    <span style="color: #000000;">}</span>
</pre>
</div></li>
<li class="fragment appear">Prove the following CSL triple:</li>

</ul>
<div>
\begin{aligned}
  \{True\}\ mk\_oneshot\ ()\
    \left\{
      c.\forall v.
      \begin{array}{l}
        \{True\}\ c.tryset\ v\ \{w.w\in \{true,false\}\}\ * \\
        {}
        \{True\}\ c.check\ () \{f.\{True\}f\ ()\ \{True\}\}
      \end{array}
    \right\}
\end{aligned}

</div>
</section>
</section>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/math/math.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
minScale: 1.00,
maxScale: 1.00,

transition: 'slide',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMath ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
