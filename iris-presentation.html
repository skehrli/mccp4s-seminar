<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Iris</title>
<meta name="author" content="Xinglu & Sascha"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/theme/moon.css" id="theme"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Iris</h1><h2 class="author">Xinglu &amp; Sascha</h2>
</section>

<section>
<section id="slide-orgdecb2cc">
<h2 id="orgdecb2cc">What is Iris?</h2>
<div class="outline-text-2" id="text-orgdecb2cc">
</div>
</section>
<section id="slide-org8f483e9">
<h3 id="org8f483e9">Disclaimer</h3>
<ul>
<li class="fragment appear">Iris is not a small project</li>
<li class="fragment appear">123 papers and 21 doctoral theses</li>
<li class="fragment appear">Highly influential
<ul>
<li class="fragment appear">2023 Alonzo Church Award for Outstanding Contributions to Logic and Computation</li>
<li class="fragment appear">2025 Most Influential POPL Paper Award
<ul>
<li>awarded for most influential paper of last decade</li>

</ul></li>

</ul></li>

</ul>
</section>
<section id="slide-org0b14aa3">
<h3 id="org0b14aa3">Iris in one sentence</h3>
<ul>
<li class="fragment appear">Iris is a <b>generic higher-order concurrent separation logic</b>.</li>

</ul>
</section>
<section id="slide-orgd803056">
<h3 id="orgd803056">Iris in one (longer) sentence</h3>
<p class="fragment (appear)">
Iris is a framework for
</p>
<ul>
<li class="fragment appear">foundational machine-checked proofs</li>
<li class="fragment appear">of deep correctness properties</li>
<li class="fragment appear">for fine-grained concurrent programs</li>
<li class="fragment appear">in higher-order imperative languages</li>

</ul>
</section>
<section id="slide-org2b8cba0">
<h3 id="org2b8cba0">Some Notes</h3>
<ul>
<li class="fragment appear">formalized entirely in Rocq proof assistant</li>
<li class="fragment appear">not tied to particular language semantics</li>
<li class="fragment appear">example: type safety proof of (a realistic subset of) Rust formalized using Iris</li>

</ul>
</section>
</section>
<section>
<section id="slide-org965320c">
<h2 id="org965320c">Who is behind Iris?</h2>

<div id="orgd92dc11" class="figure">
<p><img src="authors.png" alt="authors.png" />
</p>
</div>
</section>
</section>
<section>
<section id="slide-org72aea53">
<h2 id="org72aea53">A Brief History of Separation logic</h2>
<div class="outline-text-2" id="text-org72aea53">
</div>
</section>
<section id="slide-orge6d9824">
<h3 id="orge6d9824">What is Separation Logic?</h3>
<ul>
<li class="fragment appear">extension of Hoare Logic</li>
<li class="fragment appear">allows reasoning about pointer-manipulating programs</li>
<li class="fragment appear">initially introduced by O&rsquo;Hearn in 2001</li>
<li class="fragment appear">later extended to CSL</li>
<li class="fragment appear">solves two problems - Object Orientation and Concurrency</li>

</ul>
</section>
<section id="slide-orgc1c2866">
<h3 id="orgc1c2866">Motivation: Why Separation Logic?</h3>
<ul>
<li class="fragment appear"><p>
Consider program:
</p>
<div class="org-src-container">

<pre class="src src-c">  <span style="color: #c0caf5;">void</span> <span style="color: #7aa2f7;">f</span><span style="color: #a9b1d6;">(</span><span style="color: #c0caf5;">int</span>* <span style="color: #c0caf5;">x</span>, <span style="color: #c0caf5;">int</span>* <span style="color: #c0caf5;">y</span><span style="color: #a9b1d6;">)</span> <span style="color: #a9b1d6;">{</span>
    *x = <span style="color: #ff9e64; font-weight: bold;">1</span>;
    *y = <span style="color: #ff9e64; font-weight: bold;">2</span>;
  <span style="color: #a9b1d6;">}</span>
</pre>
</div></li>
<li class="fragment appear"><p>
Naive Hoare logic spec:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #a9b1d6;">{</span> <span style="color: #ff9e64;">true</span> <span style="color: #a9b1d6;">}</span> <span style="color: #7aa2f7;">f</span><span style="color: #a9b1d6;">(</span>x, y<span style="color: #a9b1d6;">)</span> <span style="color: #a9b1d6;">{</span> *x == <span style="color: #ff9e64; font-weight: bold;">1</span> ^ *y == <span style="color: #ff9e64; font-weight: bold;">2</span> <span style="color: #a9b1d6;">}</span>
</pre>
</div></li>
<li class="fragment appear">What if \(x == y\)? Spec becomes invalid!</li>
<li class="fragment appear"><p>
What we want instead:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #a9b1d6;">{</span> <span style="color: #9ece6a;">"x and y disjoint"</span> <span style="color: #a9b1d6;">}</span> <span style="color: #7aa2f7;">f</span><span style="color: #a9b1d6;">(</span>x, y<span style="color: #a9b1d6;">)</span> <span style="color: #a9b1d6;">{</span> *x == <span style="color: #ff9e64; font-weight: bold;">1</span> ^ *y == <span style="color: #ff9e64; font-weight: bold;">2</span> <span style="color: #a9b1d6;">}</span>
</pre>
</div></li>

</ul>
</section>
<section id="slide-orgb9eaf50">
<h3 id="orgb9eaf50">Separation Logic: Notation</h3>
<ul>
<li class="fragment appear">\(↦\) : points-to assertion (e.g. \(x ↦ 5\))
<ul>
<li class="fragment appear">memory location with name x has value 5</li>
<li class="fragment appear">assertion provides exclusive ownership over x</li>

</ul></li>
<li class="fragment appear">\(*\) : separating conjunction (e.g. \(P * Q\))
<ul>
<li class="fragment appear">like \(P \land Q\)</li>
<li class="fragment appear">BUT P and Q must be satisfied in non-intersecting parts of heap</li>

</ul></li>
<li class="fragment appear"><p>
Can now formulate this:
</p>
<div>
\begin{aligned}
\{ x ↦ v_1 * y ↦ v_2 \}\ f(x, y)\ \{ x ↦ 1 * y ↦ 2 \}
\end{aligned}

</div></li>

</ul>
</section>
<section id="slide-orgf40cd0b">
<h3 id="orgf40cd0b">Semantics of \(*\)</h3>
<div>
\begin{aligned}
(P * Q)(h) \iff \exists h_1, h_2.~ h = h_1 \uplus h_2 \land P(h_1) \land Q(h_2)
\end{aligned}

</div>
<ul>
<li class="fragment appear">\(P * Q\) holds if:
<ul>
<li>Heap can be split into disjoint parts \(h1,\ h2\)</li>
<li>\(P\) holds on \(h1\), \(Q\) on \(h2\)</li>

</ul></li>

</ul>
</section>
<section id="slide-org8664782">
<h3 id="org8664782">Frame Rule</h3>
<div>
\begin{aligned}
\frac{\{P\}~C~\{Q\}}{\{P * R\}~C~\{Q * R\}}
\end{aligned}

</div>

<ul>
<li class="fragment appear">Simple, but encapsulates &ldquo;ownership reasoning&rdquo; of separation logic.</li>
<li class="fragment appear">Only possible because of ownership semantics of points-to assertion.</li>
<li class="fragment appear"><p>
example:
</p>
<div>
\begin{aligned}
\{x ↦ 0\}\ y := new\ (42)\ \{x ↦ 0 * y ↦ 42\}
\end{aligned}

</div></li>

</ul>
</section>
<section id="slide-orge40c2a6">
<h3 id="orge40c2a6">Conclusion thus far</h3>
<ul>
<li class="fragment appear">Convenient reasoning for shared heap where everyone operates on disjoint data</li>
<li class="fragment appear">But at some point, there <b>will</b> be shared data</li>

</ul>
</section>
</section>
<section>
<section id="slide-orgabf7b91">
<h2 id="orgabf7b91">CSL: Reasoning about shared data</h2>
<div class="outline-text-2" id="text-orgabf7b91">
</div>
</section>
<section id="slide-orgf9ba7c5">
<h3 id="orgf9ba7c5">Separation Logic &rarr; CSL: O&rsquo;Hearn 2007</h3>
<ul>
<li>O&rsquo;Hearns CSL = SL + resource invariants</li>
<li>a quick example</li>
<li>ppl liked this, avalanche of subsequent works</li>
<li>problem: every new paper/library had a slightly different way about the shared data reasoning part</li>
<li>everyone came up with their own separation logic with its own primitives and proof rules</li>
<li>positional paper 2010: CSL must be unified, a common framework s.t. ppl can focus on actually verifying things and not respin the metatheory every time</li>

</ul>
</section>
</section>
<section>
<section id="slide-org7bfafd8">
<h2 id="org7bfafd8">Enter Iris: CSL Unified</h2>
<ul>
<li>Iris is the unifying framework</li>
<li>the premise: Monoids + Invariants is all you need</li>
<li>neither idea is new, but Iris conveys how all of these previous works are some linear combination of Monoids + Invariants</li>

</ul>
</section>
</section>
<section>
<section id="slide-org6704633">
<h2 id="org6704633">Wdym Monoids + Invariants??</h2>
<div class="outline-text-2" id="text-org6704633">
</div>
</section>
<section id="slide-org774d154">
<h3 id="org774d154">Where we are so far</h3>
<ul>
<li class="fragment appear">have idea of what CSL is</li>
<li class="fragment appear">know the context and goal of Iris</li>
<li class="fragment appear">BUT
<ul>
<li class="fragment appear">what kinds of proofs do we do in Iris?</li>
<li class="fragment appear">how exactly does the Iris logic look like?</li>

</ul></li>
<li class="fragment appear">let&rsquo;s answer this with an example</li>

</ul>
</section>
<section id="slide-org17f0034">
<h3 id="org17f0034">Invariants</h3>
<ul>
<li>Allow us to reason about shared state</li>
<li>Notation: \(\boxed{R}\)</li>
<li>Duplicatable: \(\boxed{R} \vdash \boxed{R} \ast \boxed{R}\)</li>

</ul>
</section>
<section id="slide-org4b83b73">
<h4 id="org4b83b73">Working with Invariants</h4>
<p>
\[
\frac{\left\{ R \ast P \right\} \ e \ \left\{ R \ast Q \right\} \qquad e
\text{ atomic} }{\left\{ \boxed{R} \ast P \right\} \ e \ \left\{ \boxed{R} \ast Q \right\} }
\]
</p>

<ul>
<li>Invariant rule
<ul>
<li class="fragment appear">Open invariant to acquire temporary ownership of shared resource</li>
<li class="fragment appear">Once invariant is reestablished, it can be closed again</li>

</ul></li>

</ul>
</section>
<section id="slide-orgffce517">
<h4 id="orgffce517">Working with Invariants (cont&rsquo;d)</h4>
<p>
\[
\frac{\left\{ \boxed{R} \ast P \right\} \ e \ \left\{ Q \right\}
}{\left\{ R \ast P \right\} \ e \ \left\{ Q \right\} }
\]
</p>

<ul>
<li>Allocation rule
<ul>
<li class="fragment appear">Create invariant and give up ownership of \(R\)</li>

</ul></li>

</ul>
</section>
<section id="slide-org1721081">
<h4 id="org1721081">Monoids</h4>
<ul>
<li class="fragment appear">Ghost state
<ul>
<li class="fragment appear">Purely logical, unrelated from the physical state of the program</li>
<li class="fragment appear">Keep track of history of computation</li>

</ul></li>
<li class="fragment appear">Modelled as a <i>partial commutative monoid</i> (PCM)</li>
<li class="fragment appear">Set \(\lvert M \rvert \) with a zero \(\bot\), unit \(\epsilon\),
binary operation \(\cdot \)
<ul>
<li class="fragment appear">\(a \cdot b = b \cdot a\)</li>
<li class="fragment appear">\(\epsilon \cdot a = a \)</li>
<li class="fragment appear">\((a \cdot b) \cdot c = a \cdot (b \cdot c)\)</li>
<li class="fragment appear">\(\bot \cdot a = \bot\)</li>
<li class="fragment appear">\(\bot \neq \epsilon\)</li>

</ul></li>

</ul>
</section>
<section id="slide-org8f20f3b">
<h4 id="org8f20f3b">Example</h4>
<div class="org-src-container">

<pre class="fragment (appear)"><span style="color: #a9b1d6;">{</span> l &#8614; n <span style="color: #a9b1d6;">}</span>
l &#8592; addOne<span style="color: #a9b1d6;">(</span>l<span style="color: #a9b1d6;">)</span> &#8214; l &#8592; addOne<span style="color: #a9b1d6;">(</span>l<span style="color: #a9b1d6;">)</span>
<span style="color: #7dcfff; font-weight: bold;">!</span>l
<span style="color: #a9b1d6;">{</span> v. v &#8805; n + <span style="color: #ff9e64; font-weight: bold;">1</span> <span style="color: #a9b1d6;">}</span>
</pre>
</div>

<ul>
<li>where <code>addOne(l)</code> is an atomic version of <code>!l + 1</code>.</li>

</ul>
</section>
<section id="slide-orgc2a6a07">
<h3 id="orgc2a6a07">An example program</h3>
<ul>
<li class="fragment appear">Consider instantiation of Iris with a &lambda;-Calculus</li>
<li class="fragment appear"><p>
Consider the following object:
</p>
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ff9e64;">mk_oneshot</span> := &#955;_.
    let x = ref<span style="color: #a9b1d6;">(</span>inl<span style="color: #7aa2f7;">(</span><span style="color: #ff9e64; font-weight: bold;">0</span><span style="color: #7aa2f7;">)</span><span style="color: #a9b1d6;">)</span> in <span style="color: #a9b1d6;">{</span>
      tryset = &#955;n. <span style="color: #ff9e64;">CAS</span><span style="color: #7aa2f7;">(</span>x, inl<span style="color: #ff9e64;">(</span><span style="color: #ff9e64; font-weight: bold;">0</span><span style="color: #ff9e64;">)</span>, inr<span style="color: #ff9e64;">(</span>n<span style="color: #ff9e64;">)</span><span style="color: #7aa2f7;">)</span>,
      check = &#955;_.
        let y = <span style="color: #7dcfff; font-weight: bold;">!</span>x in &#955;_.
          match y,<span style="color: #7dcfff; font-weight: bold;">!</span>x with
            | inl<span style="color: #7aa2f7;">(</span>_<span style="color: #7aa2f7;">)</span>,_      &#8658; <span style="color: #7aa2f7;">()</span>
            | inr<span style="color: #7aa2f7;">(</span>n<span style="color: #7aa2f7;">)</span>,inl<span style="color: #7aa2f7;">(</span>_<span style="color: #7aa2f7;">)</span> &#8658; assert<span style="color: #7aa2f7;">(</span><span style="color: #ff9e64;">false</span><span style="color: #7aa2f7;">)</span>
            | inr<span style="color: #7aa2f7;">(</span>n<span style="color: #7aa2f7;">)</span>,inr<span style="color: #7aa2f7;">(</span>m<span style="color: #7aa2f7;">)</span> &#8658; assert<span style="color: #7aa2f7;">(</span>n = m<span style="color: #7aa2f7;">)</span>
          end
    <span style="color: #a9b1d6;">}</span>
</pre>
</div></li>
<li class="fragment appear"><p>
We want to prove the following CSL triple:
</p>
<span style="font-size:70%">
<div>
\begin{aligned}
\{True\}\ mk\_oneshot\ ()\
\left\{
c.\forall v.
\begin{array}{l}
        \{True\}\ c.tryset\ v\ \{w.w\in \{true,false\}\}\ * \\
        {}
        \{True\}\ c.check\ () \{f.\{True\}f\ ()\ \{True\}\}
\end{array}
\right\}
\end{aligned}

</div>
</span></li>

</ul>
</section>
</section>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/math/math.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
minScale: 1.00,
maxScale: 1.00,

transition: 'slide',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMath ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
