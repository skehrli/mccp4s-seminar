:REVEAL_PROPERTIES:
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_VERSION: 4
#+REVEAL_THEME: moon
#+REVEAL_TRANS: slide
#+REVEAL_MIN_SCALE: 1.0
#+REVEAL_MAX_SCALE: 1.0
#+REVEAL_PLUGINS: (math)
#+OPTIONS: toc:nil num:nil timestamp:nil
:END:

#+TITLE: Iris
#+AUTHOR: Xinglu & Sascha

* What is Iris?
** Disclaimer
#+ATTR_REVEAL: :frag (appear)
- Iris is not a small project
- 123 papers and 21 doctoral theses
- Highly influential
  #+ATTR_REVEAL: :frag (appear)
  + 2023 Alonzo Church Award for Outstanding Contributions to Logic and Computation
  + 2025 Most Influential POPL Paper Award
    - awarded for most influential paper of last decade
** Iris in one sentence
#+ATTR_REVEAL: :frag (appear)
- Iris is a *generic higher-order concurrent separation logic*.
** Iris in one (longer) sentence
#+ATTR_REVEAL: :frag (appear)
Iris is a framework for
#+ATTR_REVEAL: :frag (appear)
+ foundational machine-checked proofs
+ of deep correctness properties
+ for fine-grained concurrent programs
+ in higher-order imperative languages
** Some Notes
#+ATTR_REVEAL: :frag (appear)
- formalized entirely in Rocq proof assistant
- not tied to particular language semantics
- example: type safety proof of (a realistic subset of) Rust formalized using Iris
* Who is behind Iris?
:PROPERTIES:
:ID:       ab7c0539-4948-46c7-8fba-5591d366ef3a
:END:
#+attr_org: :width 600px
[[file:authors.png]]
* A Brief History of Separation logic
** What is Separation Logic?
#+ATTR_REVEAL: :frag (appear)
- extension of Hoare Logic
- allows reasoning about pointer-manipulating programs
- initially introduced by O'Hearn in 2001
- later extended to CSL
- solves two problems - Object Orientation and Concurrency
** Motivation: Why Separation Logic?
#+ATTR_REVEAL: :frag (appear)
- Consider program:
  #+BEGIN_SRC c
  void f(int* x, int* y) {
    *x = 1;
    *y = 2;
  }
  #+END_SRC
- Naive Hoare logic spec:
  #+begin_src c
{ true } f(x, y) { *x == 1 ^ *y == 2 }
  #+end_src
- What if $x == y$? Spec becomes invalid!
- What we want instead:
  #+begin_src c
{ "x and y disjoint" } f(x, y) { *x == 1 ^ *y == 2 }
  #+end_src

** Separation Logic: Notation
#+ATTR_REVEAL: :frag (appear)
 - $↦$ : points-to assertion (e.g. $x ↦ 5$)
   #+ATTR_REVEAL: :frag (appear)
   - memory location with name x has value 5
   - assertion provides exclusive ownership over x
 - $*$ : separating conjunction (e.g. $P * Q$)
   #+ATTR_REVEAL: :frag (appear)
   - like $P \land Q$
   - BUT P and Q must be satisfied in non-intersecting parts of heap
 - Can now formulate this:
        \begin{aligned}
        \{ x ↦ v_1 * y ↦ v_2 \}\ f(x, y)\ \{ x ↦ 1 * y ↦ 2 \}
        \end{aligned}
** Semantics of $*$
\begin{aligned}
(P * Q)(h) \iff \exists h_1, h_2.~ h = h_1 \uplus h_2 \land P(h_1) \land Q(h_2)
\end{aligned}
#+ATTR_REVEAL: :frag (appear)
- Heap can be split into disjoint parts $h1,\ h2$
- $P$ holds on $h1$, $Q$ on $h2$

** Frame Rule
\begin{aligned}
\frac{\{P\}~C~\{Q\}}{\{P * R\}~C~\{Q * R\}}
\end{aligned}

#+ATTR_REVEAL: :frag (appear)
- Simple, but encapsulates "ownership reasoning" of separation logic.
- Only possible because of ownership semantics of points-to assertion.
- example:
  \begin{aligned}
  \{x ↦ 0\}\ y := new\ (42)\ \{x ↦ 0 * y ↦ 42\}
  \end{aligned}
** SL \to CSL (O'Hearn, 2007)
#+ATTR_REVEAL: :frag (appear)
- Add parallel execution $\parallel$ (e.g. $C_1 \parallel C_2$)
- And this simple rule (parallel composition):
  \begin{aligned}
  \frac{\{P_1\}~C_1~\{Q_1\}\ldots \{P_n\}~C_n~\{Q_n\}}{\{P_1 * \ldots * P_n\}~C_1\parallel\ldots\parallel C_n~\{Q_1 * \ldots * Q_n\}}
  \end{aligned}
** Conclusion thus far
#+ATTR_REVEAL: :frag (appear)
- Convenient reasoning for shared heap where everyone operates on disjoint data
- But at some point, there *will* be shared data
** CSL: Reasoning about shared data
#+ATTR_REVEAL: :frag (appear)
- O'Hearns original CSL = SL + $\parallel$ + *resource invariants*
- critical region rule:
  \begin{aligned}
  \frac{\{(P * RI_r) \land B\}~C~\{Q * RI_r\}}{\{P\}~with\ r\ when\ B\ do\ C~\{Q\}}
  \end{aligned}
- shifts proof burden to coming up with a good resource invariant
- paper included correctness proof for simple concurrent queue
** Where are we now?
#+ATTR_REVEAL: :frag (appear)
- ppl impressed by capabilities of CSL, avalanche of subsequent work follows
- problem: every new paper/library has slightly different way about shared resource reasoning part
- everyone came up with own separation logic with own primitives and proof rules
- Parkinson, 2010: CSL must be unified in a common framework
 - ppl can focus on actually verifying things
* Enter Iris: CSL Unified (Jung, 2015)
#+ATTR_REVEAL: :frag (appear)
- Iris is the unifying framework
- the premise: Monoids + Invariants are all you need
- neither idea new, but presented as unification of previous approaches
- Goal of Iris: a minimal generic base logic that can derive all previous logics
* Wdym Monoids + Invariants??
** Monoids + Invariants: Conceptually
#+ATTR_REVEAL: :frag (appear)
- assume shared memory location $a$
- we want to prove that some concurrent access protocol on $a$ is correct
- idea: create a 'ghost location' $b$ representing $a$ and describe the protocol on $b$
  #+ATTR_REVEAL: :frag (appear)
  + $b$ follows a certain structure (Monoid)
  + the operations of Monoid defined by user to encode protocol
- idea 2: tie the state of $b$ to $a$ with invariants
- Monoid: Generic structure to express protocol
- Invariant: Enforce protocol
** Invariants
- Allow us to reason about shared state
- Notation: \(\boxed{R}\)
- Duplicable: \(\boxed{R} \vdash \boxed{R} \ast \boxed{R}\)

*** Working with Invariants
\[
\frac{\left\{ R \ast P \right\} \ e \ \left\{ R \ast Q \right\} \qquad e
\text{ atomic} }{\left\{ \boxed{R} \ast P \right\} \ e \ \left\{ \boxed{R} \ast Q \right\} }
\]

- Invariant rule
   #+ATTR_REVEAL: :frag (appear)
  + Open invariant to acquire temporary ownership of shared resource
  + Once invariant is reestablished, it can be closed again

*** Working with Invariants (cont'd)
\[
\frac{\left\{ \boxed{R} \ast P \right\} \ e \ \left\{ Q \right\}
}{\left\{ R \ast P \right\} \ e \ \left\{ Q \right\} }
\]

- Allocation rule
   #+ATTR_REVEAL: :frag (appear)
   - Create invariant and give up ownership of \(R\)
       
*** Monoids
#+ATTR_REVEAL: :frag (appear)
- Ghost state
   #+ATTR_REVEAL: :frag (appear)
  + Purely logical, unrelated from the physical state of the program
  + Keep track of history of computation
- Modelled as a /partial commutative monoid/ (PCM)
   + Taken as parameter of the logic
- Set \(\lvert M \rvert \) with a zero \(\bot\), unit \(\epsilon\),
  binary operation \(\cdot \)
  #+ATTR_REVEAL: :frag (appear)
  + \(a \cdot b = b \cdot a\)
  + \(\epsilon \cdot a = a \)
  + \((a \cdot b) \cdot c = a \cdot (b \cdot c)\)
  + \(\bot \cdot a = \bot\)
  + \(\bot \neq \epsilon\)

*** Ghost state
#+ATTR_REVEAL: :frag (appear)
- For element \(a\) in Monoid, exists corresponding ghost
  assertion \(\boxed{a}_{g}\)
  + Asserts \(a \neq \bot\) & ownership of an \(a\) fragment of
    the global ghost state
- Can update global ghost state
   + Expressed as /view shifts/
   + \(P \Rrightarrow Q\): Can update the state from \(P\) to \(Q\) without
     changing program state
- Ghost resources can be split and combined arbitrarily: \(\boxed{t \cdot
  u}_{g} \iff  \boxed{t}_{g} \ast \boxed{u}_{g}\)

*** Ghost state
\[
\frac{a \rightsquigarrow B}{\boxed{a}_{g} \Rrightarrow \exists b \in B. \boxed{b}_{g}}
\]

#+ATTR_REVEAL: :frag (appear)
- \(a \rightsquigarrow B\) is shortand for \(\Box \forall a_{f}.  \ a
  \cdot a_{f} \neq \bot \implies \exists b \in B. \ b \cdot a_{f} \neq
  \bot\)
- Always modality \(\Box P\)
  + \(P\) holds; does not assert ownership
  + Duplicatable
- Frame update rule
  + State obtained by composing the contributions of all threads is a
    valid element (not \(\bot\))

*** Example
#+begin_src c
{ l ↦ n }
l ← addOne(l) ‖ l ← addOne(l)
!l
{ v. v = n + 2 }
#+end_src

#+ATTR_REVEAL: :frag (appear)
- Use the /authoritative monoid/
   #+ATTR_REVEAL: :frag (appear)
  + Ghost variables come in pairs \(\gamma \hookrightarrow_{\bullet} n \ast \gamma    \hookrightarrow_{\circ} n\)
  + One owns the global authoritative state of ghost resource
  + Everyone else owns fragments of resource
- Invariant: \(\exists n_{1}, n_{2}. (n_{1} + n_{2}) \ast \gamma_{1} \hookrightarrow_{\bullet} n_{1} \ast
  \gamma_{2} \hookrightarrow_{\bullet} n_{2}\)

*** Example

** An example program
#+ATTR_REVEAL: :frag (appear)
- Consider instantiation of Iris with a \lambda-Calculus
- Consider the following object:
  #+begin_src c
mk_oneshot := λ_.
    let x = ref(inl(0)) in {
      tryset = λn. CAS(x, inl(0), inr(n)),
      check = λ_.
        let y = !x in λ_.
          match y,!x with
            | inl(_),_      ⇒ ()
            | inr(n),inl(_) ⇒ assert(false)
            | inr(n),inr(m) ⇒ assert(n = m)
          end
    }
  #+end_src
- Prove the following CSL triple:
  #+REVEAL_HTML: <span style="font-size:70%">
  \begin{aligned}
  \{True\}\ mk\_oneshot\ ()\
  \left\{
  c.\forall v.
  \begin{array}{l}
          \{True\}\ c.tryset\ v\ \{w.w\in \{true,false\}\}\ * \\
          {}
          \{True\}\ c.check\ () \{f.\{True\}f\ ()\ \{True\}\}
  \end{array}
  \right\}
  \end{aligned}
  #+REVEAL_HTML: </span>

* Discussion
** Strengths/Limitations
#+REVEAL_HTML: <div class="column" style="float:left; width: 50%">
#+ATTR_REVEAL: :frag appear
*Strengths*
#+ATTR_REVEAL: :frag (appear)
- clear goal, no overpromise
- tremendous impact
#+REVEAL_HTML: </div>
#+REVEAL_HTML: <div class="column" style="float:right; width: 50%">
#+ATTR_REVEAL: :frag appear
*Limitations*
#+ATTR_REVEAL: :frag (appear)
- Logic overly complicated in 2015 paper (Iris 1.0), later simplified
- (Partial Commutative) Monoids ended up not being all you need
- did it really unify CSL?
  #+ATTR_HTML: :width 100%
  [[file:csl-family-tree.png]]
#+REVEAL_HTML: </div>
